[{"title":"JVM垃圾回收算法","url":"/2022/03/26/JVM%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/","content":"标记清除算法复制算法标记压缩算法","categories":["JVM"]},{"title":"Go语言学习","url":"/2022/04/16/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/","content":"Go语言学习笔记2022年04月13日第一个hello,world程序.\npackage mainimport &quot;fmt&quot;func main() &#123;\tfmt.Println(&quot;hello,world&quot;)&#125;\n\n一个go文件只属于一个包,go文件的开头必须是 main包下 go 分为两种 ,一种是可执行的包,一种是工具包.工具包不能执行,但是拓展了主应用的功能\ngo语言命名规则需要对外暴露的变量的名字首字母必须大写,不需要对外暴露的变量名首字母用小写\n包名尽量用小写,尽量不要和标准库的命名冲突,不要用大小写混合或下划线命名\n2022年04月14日简短定义变量 变量名:&#x3D;值 这种方式的缺点是\n\n无法定义数据类型\n只能在函数内部\n定义变量同时显示初始化\n\nvar hp int hp:&#x3D;10\n\n报错信息no new variables on left side of :&#x3D;\n\n这样的话程序会报错 因为在第一行hp已经被声明过了\nconn, err :&#x3D; net.Dial(“tcp”, “127.0.0.1:8080”)conn1, err :&#x3D; net.Dial(“tcp”, “127.0.0.1:8080”)在多个简短变量声明和赋值中,至少有一个新的变量出现在左值中\nSwap a and bpackage mainimport &quot;fmt&quot;func main() &#123;\ta := 1\tb := 2\tvar t int\tt = a\ta = b\tb = t\tfmt.Println(a)\tfmt.Println(b)\t//第二种方法\tc := 1\td := 2\tc, d = d, c\tfmt.Println(c)\tfmt.Println(d)&#125;\n\n\n2022年04月15日匿名变量匿名变量不占用空间,也不会分配内存,多个匿名变量之间没有任何影响定义一个函数getdata()\npackage mainimport &quot;fmt&quot;func getdata() (int, int) &#123;\treturn 10, 100&#125;func main() &#123;\ta,_ :=getdata() //定义第二个接收值为匿名变量,在后续代码中不能被调用\t_,b :=getdata() //定义第一个接收值为匿名变量\tfmt.Println(a)\tfmt.Println(b)&#125;\n\n变量的作用域局部变量 是在函数内声明的变量,局部变量只在函数内有效,函数调用结束后,变量就会被销毁.\n全局变量是在函数外部声明的Go语言函数内可以声明和全局变量相同名称的变量,在使用时,会优先使用函数内的局部变量.\n形式参数\nfunc test(形式参数)&lt;返回值类型&gt;{    函数体}\npackage mainimport &quot;fmt&quot;/** * @ Author     ：zhaolengquan. * @ Date       ：Created in 23:44 2022/4/15 * @ Description： */func main() &#123;\tvar a = 10\tvar b = 20\tfmt.Printf(&quot;main()函数中a=%d\\n&quot;, a)\tfmt.Printf(&quot;main()函数中b=%d\\n&quot;, b)\tc := sum(a, b)\tfmt.Printf(&quot;sum函数的返回值是%d&quot;, c)&#125;func sum(a, b int) int &#123;\tfmt.Printf(&quot;sum函数中a=%d\\n&quot;, a)\tfmt.Printf(&quot;sum函数中b=%d\\n&quot;, b)\treturn a+b&#125;\n\n2022年04月17日22:43:14强制类型转换\n    var f1 float64 = 2.333f2 := int(f1)fmt.Println(f1, f2)//输出结果 2.333 2\n\nString转int\npackage mainimport (\t&quot;fmt&quot;\t&quot;strconv&quot;)func main() &#123;\tstring1 := &quot;112233&quot;\tatoi, err := strconv.Atoi(string1)\tfmt.Println(string1, atoi, err)&#125;\n\n判断字符串是否以某个字符开头或结尾\npackage mainimport (\t&quot;strings&quot;\t&quot;fmt&quot;)func main() &#123;\tstr := &quot;hexo&quot;\tfmt.Println(strings.HasPrefix(str, &quot;h&quot;)) //判断str是否以h字母开头\tfmt.Println(strings.HasSuffix(str, &quot;o&quot;)) //str是否以o字母结尾\t//输出结果 true true\t//Containsany(s string,char string )s包含char中任意一个字符\tprintln(strings.ContainsAny(&quot;abc&quot;, &quot;ddd&quot;))  //返回false\tprintln(strings.ContainsAny(&quot;abc&quot;, &quot;ddda&quot;)) //返回true\t//Contains(s string,substring string) s中包含substring 返回true\tprintln(strings.Contains(&quot;abc&quot;, &quot;ab&quot;)) //返回true\t//Compare方法比较字符串 如果相等返回0\tprintln(strings.Compare(&quot;abc&quot;, &quot;abc&quot;))\t//判断substr在s中的位置\tprintln(strings.Index(&quot;abcde&quot;, &quot;cd&quot;))\t//转换成大写字符\tstrings.ToUpper(&quot;abc&quot;)&#125;\n\n\n\n\n\n\n\n","categories":["Go语言"]},{"title":"Bean作用域","url":"/2022/03/17/Bean%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Bean的作用域\nSingleton\n\nBean的作用域默认是单例的\n\nPrototype\n\n每次创建都会返回一个新的Bean实例\n\nrequest 和Session 在web中有效\n\nrequest 每次的HTTP请求都会产生一个新的Bean  仅在当前http请求中有效\nSession 每一次来自新 session的HTTP请求都会产生一个新的 bean该bean仅在当前HTTPsession 内有效。\n怎么配置Spring bean 的作用域\n\n在XML中配置\n\n&lt;bean id=&quot;......&quot;  class=&quot;......&quot;   scope=&quot;Singleton&quot;&gt;&lt;/bean&gt;\n\n\n使用注解@Scope 配置\n\n@Repository@Scope(&quot;prototype&quot;)public class UserDao &#123;    public String hello() &#123;        return &quot;userdao&quot;;    &#125;&#125;\n\n\n\n","categories":["框架"],"tags":["Spring"]},{"title":"JVM常用的垃圾回收器","url":"/2022/03/26/JVM%E5%B8%B8%E7%94%A8%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/","content":"SerialparNewCMS","categories":["JVM"]},{"title":"Nginx负载均衡","url":"/2022/03/16/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","content":"什么是反向代理服务器反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。反向代理通过proxy_pass指令来实现。\nNginx配置#HTTP里的配置        upstream mydata &#123;        #mydata是自己起的名字,可以随便起,下面 location的proxy_pass 有用到        \t\t\t\t# weight是权重          \t\t\t\t# 权重的数值越大，被分配到的几率也更大                server localhost:8181 weight=2;                server localhost:8182 weight=1;        &#125;    server &#123;        listen       80; #服务器监听80端口        server_name  localhost;        location / &#123;            root   html;            index  index.html index.htm;                       # 监听地址, mydata 即用户访问的地址            proxy_pass http://mydata  ;        &#125;\n\n\n\n引入Thymeleaf视图解析器必要的start依赖\n    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;\n\n\n\nJava代码配置localhost:8181package com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class NginxController &#123;\t@RequestMapping(&quot;/&quot;)\tpublic String test() &#123;\t\treturn &quot;Nginx&quot;;\t&#125;&#125;\n\nNginx.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    localhost8181: hello Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\napplication.ymlserver:  port: 8181    mvc:    static-path-pattern: /**  web:    resources:      static-locations: classpath:/templates/,classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/\n\nlocalhost:8182controller不需要改变,application.yml里port改成8182\nhtml稍做变化\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    localhost8182: hello Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n用Maven把项目打成Jar包后 修改html和端口再次打包\n\njava -jar SpringBoottest-0.0.1-SNAPSHOT.jar \njava -jar SpringBoottest-0.0.1-SNAPSHOT2.jar \n访问Nginx  localhost:80\n刷新能得到不同的效果\n\n\n\n\nNginx负载均衡的几种方式普通轮询算法    upstream mydata &#123;            server localhost:8181             server localhost:8182     &#125;server &#123;    listen       80; #服务器监听80端口    server_name  localhost;    location / &#123;        root   html;        index  index.html index.htm;               # 监听地址, mydata 即用户访问的地址        proxy_pass http://mydata  ;    &#125;\n\n基于比例加权平均upstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;&#125;\n\n基于IP路由负载上面两种方式都有一个问题 如果我们的请求不是无状态的时候(采用Session保存数据),比如我们把登录信息保存到了Session中,那么跳转到另外一台服务器的时候,就需要重新登陆了,此时可以在upstream 配置中加一行 ip_hash, ip_hash首先把每一个请求 先获得请求的ip地址映射成一个hash值,这样的话每个ip都可以固定访问一台后端服务器,解决了Session跨域的问题\nupstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;        ip_hash;&#125;\n\n\n\n基于服务器响应时间负载分配根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。\nupstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;       \tfair;&#125;\n\n\n\n对不同域名实现负载均衡    upstream AdminConfig &#123;            server localhost:8181             server localhost:8182     &#125;        upstream StudentConfig &#123;            server localhost:8181             server localhost:8182     &#125;server &#123;    listen       80; #服务器监听80端口    server_name  localhost;    location /Admin/ &#123;        root   html;        index  index.html index.htm;       # 监听地址, mydata 即用户访问的地址        proxy_pass http://AdminConfig  ;    &#125;        location /Student/ &#123;        root   html;        index  index.html index.htm;       # 监听地址, mydata 即用户访问的地址        proxy_pass http://StudentConfig  ;    &#125;\n\n\n\n","categories":["Nginx"],"tags":["Nginx","负载均衡"]},{"title":"MySQL实战45讲总结","url":"/2022/03/12/Mysql/","content":"MySQL自增主键\n页分裂 页合并\n回表操作\n二级索引放的数据是主键ID\n\n\n2022-03-10 10:27:44\nMySQL缓存 (8.0以后已经弃用), 对基础表的任何修改 都会使所有的缓存失效,\n如果想要一条SQL命中缓存,需要和之前存入缓存的SQL完全一致,参数顺序不同或 多了空格 都会导致不会命中缓存.\n除非表是一张静态表 没有更新只有查询的需求 可以使用缓存提高效率\n如果没有命中缓存 SQL就来到了解析器 首先进入分析器  进行  词法分析 然后语法分析(看语句是否合法)\n分析器任务完成后, 来到优化器\n优化器的作用是 索引选择 和表连接顺序(join)\n一条查询语句的执行需要经过\n连接器-分析器-优化器-执行器\n连接器(建立连接,权限认证)\n分析器(分析词法,语法是否正确)\n优化器(选择索引和连接方式)\n执行器(执行之前需要看用户有没有对表的查询权限)\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"MySQL新建索引规则","url":"/2022/03/30/MySQL%E6%96%B0%E5%BB%BA%E7%B4%A2%E5%BC%95%E8%A7%84%E5%88%99/","content":"索引越多越好吗？索引并不是越多越好，\n\n索引会占用较多的磁盘空间\n创建和维护索引需要耗费时间，而且索引过多会影响其他语句的执行效率\n\n索引的创建\n数据量较少的时候不建议创建索引，如果优化器判断出全表扫描比走索引更高效的时候，就不会选择走索引。\n对查询频率较高的字段创建索引，会大幅提高性能\n尽量能覆盖到常用的查询字段\n尽量选择数据量小的字段做索引，如果索引列字段较大，占用空间太大，则会影响查询效率\n\n","categories":["MySQL"],"tags":["索引"]},{"title":"MySQL索引分析_01","url":"/2022/03/13/index/","content":"\n表结构如下\n\n表名为T,主键是id 自增, 新建索引name.\nCREATE TABLE `T` (  `id` int NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `age` int DEFAULT NULL,  `adress` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `test` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n\n\nusing IndexEXPLAIN SELECT id from t where name =&#x27;lisi&#x27;;\n\n使用了覆盖索引 要查的id 就在name索引的叶子结点上\nusing where在使用索引的情况下,需要回表查询数据\nusing where &amp; using IndexEXPLAIN SELECT id from t where name LIKE &#x27;li%&#x27;;\n\n使用了索引,所需要的数据在索引列上都能找到, 不需要回表操作\nusing Index conditionEXPLAIN SELECT * from t where name LIKE &#x27;li%&#x27;;\n\n虽然使用了索引,但是还需要回表查询数据\n索引下推在MySQL5.6以后引入新特性 索引下推\nCREATE INDEX test2 ON T (name,age)EXPLAIN SELECT * from t WHERE name like &#x27;li%&#x27; AND age =10 \n\n在MySQL5.6版本以前 上述SQL执行流程:\n因为name和age是联合索引,但是因为name是范围查询(&gt; &lt; between like) 根据name排序之后age索引就失效了 所以就带着id去回表查询age是否复合条件\n和下图(列名不同)但原理相同\n\nMySQL5.6以后引入索引下推SQL执行流程是\n在根据name查询以后,InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。\n","categories":["MySQL"],"tags":["索引"]},{"title":"Volatile关键字","url":"/2022/03/14/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/","content":"为什么会出现线程不安全的问题volatile既然是与线程安全有关的问题，那我们先来了解一下计算机在处理数据的过程中为什么会出现线程不安全的问题。\n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。\n为了处理这个问题，在CPU里面就有了高速缓存(Cache)的概念。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n我举个简单的例子，比如cpu在执行下面这段代码的时候,\nt=t+1;\n\n\n\n会先从高速缓存中查看是否有t的值，如果有，则直接拿来使用，如果没有，则会从主存中读取，读取之后会复制一份存放在高速缓存中方便下次使用。之后cpu进行对t加1操作，然后把数据写入高速缓存，最后会把高速缓存中的数据刷新到主存中。\n这一过程在单线程中运行是没问题的, 在多线程中运行就会出现问题,在多核CPU中,每个线程可能运行在不同的CPU中,每个CPU都有自己的高速缓存,这时就会出现同一个变量在两个高速缓存中的值不一致的问题了.\n假设此时t的值为0,两个线程同时读取了t的值,并存到了各自的高速缓存中,线程1对t进行了加1的操作,此时t的值为1,并且把t的值写回主内存,,但是线程2中高速缓存的值还是0,进行加1操作后,t的值还是1 然后把t写回主内存.此时两个线程都对t的值进行了+1操作,但是主内存中的值不是2 这就出现了数据丢失的问题,线程不安全.\njava中线程安全问题java语言在处理线程安全问题的时候,会有自己的处理机制,比如synchronized关键字, volatile关键字\njava内存模型规定所有的变量都是存在主内存中,每个线程又都有自己的工作内存(高速缓存),线程对数据的所有操作必须在自己的工作内存中进行,而不是直接在主存中操作.并且每个线程不能访问其他线程的工作内存.java中的每个线程都有自己的工作空间,因此多个线程在处理一个共享变量的时候,就会出现安全问题.\n\n共享变量\n\n上面举例的t就是一个共享变量,共享变量就是能够被多个线程访问到的变量.在java中共享变量包括实例变量,静态变量,数组元素, 他们都被存放在堆内存中\nvolatile关键字可见性可见性的意思就是在多线程环境下,一个变量如果被一个 线程修改,其他线程能够立即知道这个线程被修改了,当线程读取这个变量的时候,去主内存中读取而不是自己的工作内存.\n上面的例子中线程2读取变量时从主内存中读取,就能读到最新的线程1修改后的值,然后再进行+1操作,这样两边的数据就一致了.\n如果一个变量被声明为volatile,那么这个变量就具有了可见性的特征,这就是volatile的作用之一\n缓存一致性协议线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在\n其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。\n有序性实际上,当我们把代码写好之后,虚拟机不一定会按照我们写的代码的顺序来执行,例如下面两行代码\nint a = 1;int b = 2;\n\n对于这两句代码，你会发现无论是先执行a &#x3D; 1还是执行b &#x3D; 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行重排序的。\n为什么要重排序呢,\n假如执行int a&#x3D;1 需要100ms的时间,执行int b&#x3D;2需要1ms的时间,并且这两行代码并没有依赖关系,最终不会对ab的值造成影响,那肯定先执行b&#x3D;2这行代码了.\nvolatile真的能保证一个变量的线程安全吗我们通过上面的讲解，发现volatile关键字还是挺有用的，不但能够保证变量的可见性，还能保证代码的有序性。那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？答案是否定的。原因是因为Java里面的运算并非是原子操作。\n原子操作原子操作：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码\nint a=b+1;\n\n处理器在处理代码的时候，需要处理以下三个操作：\n\n从内存中读取b的值。\n进行a &#x3D; b + 1这个运算\n把a的值写回到内存中\n\n而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。\nvolatile无法保证原子性的例子public class test4 &#123;\tprivate static volatile int i = 0;\tpublic static void main(String[] args) &#123;\t\tfor (int j = 0; j &lt; 10; j++) &#123;\t\t\tnew Thread(() -&gt; &#123;\t\t\t\tfor (int k = 0; k &lt; 1000; k++) &#123;\t\t\t\t\ti = i + 1;\t\t\t\t&#125;\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(i);\t&#125;&#125;\n\n\n例如：线程1读取了t的值，假如t &#x3D; 0。之后线程2读取了t的值，此时t &#x3D; 0。然后线程1执行了加1的操作，此时t &#x3D; 1。但是这个时候，处理器还没有把t &#x3D; 1的值写回主存中。这个时候处理器跑去执行线程2，注意，刚才线程2已经读取了t的值，所以这个时候并不会再去读取t的值了，所以此时t的值还是0，然后线程2执行了对t的加1操作，此时t &#x3D;1 。这个时候，就出现了线程安全问题了，两个线程都对t执行了加1操作，但t的值却是1。所以说，volatile关键字并不一定能够保证变量的安全性。\n什么情况下volatile能够保证线程安全刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：\n\n运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n变量不需要与其他状态变量共同参与不变约束。\n\n","categories":["JUC"],"tags":["volatile"]},{"title":"Redis持久化详解","url":"/2022/04/02/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E8%AF%A6%E8%A7%A3/","content":"RDB持久化Redis是基于内存的数据库,如果退出进程,数据将会消失,所以我们可以把内存中的数据持久化到磁盘上,下次开启Redis进程的时候,读取磁盘中的数据到内存中,就可以继续正常使用Redis了\nRDB持久化是Redis服务器把数据库当前的状态,压缩成一个二进制的RDB文件保存到磁盘.\n数据库状态–&gt;RDB文件    RDB文件–&gt;(恢复)数据库状态\n因为RDB文件是保存在硬盘上的,就算Redis服务器停止或者宕机,计算机停机,只要RDB文件存在,Redis服务器就可以用它来还原数据库的状态.\nRDB文件的创建和载入Redis有两个命令可以生成RDB文件,\n\nSAVE\nBGSAVE\n\n他们的区别是:\nSAVE命令会阻塞Redis服务器,直到RDB文件生成之后才能处理其他命令请求\nBGSAVE命令会在后台fork出一个子进程,然后子进程用于生成RDB文件,Redis服务器仍然可以处理命令请求\nBGSAVE采用轮询等待的方式 等待子进程的信号(生成RDB结束)\nRDB文件的载入没有专门的命令执行, 只要Redis服务器在启动的时候检测到RDB文件的存在,就会自动载入RDB文件.\n\n因为AOF的更新频率比RDB文件高\n如果服务器开启了AOF功能,Redis服务器启动的时候就不会载入RDB文件,优先使用AOF文件还原数据库\n只有在AOF功能处于关闭状态时,才会默认载入RDB文件\n\n在BGSAVE命令的执行过程中,处理SAVE,BGSAVE,BGREWRITEAOF命令的方式也不同\n在Redis服务器执行BGSAVE的过程中,因为SAVE和BGSAVE, BGSAVE和BGSAVE都存在竞争关系,所以Redis服务器会拒绝SAVE和BGSAVE的请求\n其次BGSAVE和BGREWRITEAOF命令不能同时执行 如果当前是BGSAVE状态, BGREWRITEAOF将会等到BGSAVE执行后在执行\n如果当前是BGREWRITEAOF状态,服务器将会拒绝BGSAVE命令\n服务器在载入RDB文件的过程中 会一直处于阻塞状态,知道RDB文件载入完成\n自动间隔性保存Redis允许用户通过配置save选项,让服务器每隔一段时间自动运行BGSAVE命令\nsave配置文件\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n当只要满足三个条件之一,服务器就会执行BGSAVE命令\n\n900秒内至少1次修改\n300秒内至少10次修改\n60秒内至少10000次修改\n\n服务器会根据save选项设置RedisServer结构的saveparams参数\n\n\n\n\n除了saveparams参数外 服务器还维护了一个dirty计数器和一个lastsave属性\ndirty用于记录上次(成功)执行BGSAVE&#x2F;SAVE命令后数据库的修改次数\nlastsave用于记录上次(成功)执行BGSAVE&#x2F;SAVE命令后的Unix时间戳\n\n\n假设图10-8位当前服务器的状态,在经过了301秒之后(1378271101)服务器会执行一次BGSAVE,因为在300秒内数据库发生了至少10次修改.\n\n\n假设BGSAVE命令5秒后执行完成,现在数据库的状态是 dirty计数器被重新置为0, 当前lastsave时间戳被更新为1378271106(1378271101+5)\nRDB文件结构\n\n\nRedis(5字节)\ndb_version(4字节)\ndata_bases\nEOF(1字节)\ncheck_num(8字节)\n\n\n\n文件头部的Redis部分为5个字节保存着”Redis” 这五个字符,通过这5个字符可以快速的检查当前文件是否是RDB文件\ndb_version长度为4字节,记录的是RDB的默认版本号 例”0006”\ndata_bases包含0个或任意个redis数据库\nEOF为1字节,当读到EOF时标志着RDB文件正文内容的结束\ncheck_num是8字节的无符号整数,保存的是一个校验和,check_num的数值是由REDIS,db_version,data_bases,EOF四个部分计算出来的, 作用是可以校验RDB文件是否损坏或错误.\n","categories":["Redis"],"tags":["Redis"]},{"title":"面试总结","url":"/2022/03/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"\n重写和重载\n\n重写是 子类继承父类, 然后子类可以重写父类的方法\n重写时,参数类型,参数个数,方法名都要和被重写的方法完全一致!\n重写时,父类private方法不能被重写(爸爸的隐私,孩子不能看)\n子类重写的方法不能比父类的修饰符更严格\n重载发生在一个类中,方法名相同,参数个数,参数类型,参数顺序 不相同 \n\nRedis持久化方式 -RDB和AOF的优缺点\n\nRDB是快照方式需要恢复数据的时候直接把RDB快照加载就行\n如果数据较多, 保存快照的时间比较久\nAOF是写命令追加到日志, 日志文件会越来越大\n\nRDB的缺点\n\nRDB快照一般都是每五分钟或者更长时间更新一次,如果Redis宕机 可能会丢失近几分钟的数据. 这个问题就是RDB最大的缺点, 不适合做第一恢复方案\nRDB fork子进程进行数据备份,如果数据量特别大,等待时间变久,.\n所以 一般不要让RDB备份时间间隔太久, 否则每次生成的RDB文件太大了，对Redis本身的性能可能会有影响的；\n\nAOF优缺点\n\n一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据，Redis进程挂了，最多丢掉1秒钟的数据；\nAOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修；\n\nMySQL主键索引有什么用\n\n主键保证唯一性 &amp;&amp; 主键列不为NULL\n\nMySQL表主键是必须的吗\n\n主键不是必须的,简单的表可以不设置主键, 设置主键能提高表的查询效率\n如果没有定义主键,innoDB会选择唯一非空索引作为主键,如果没有的话 innoDB会自动生成一个包含了ROW_ID值的列作为聚簇索引,行都会根据这个ROW_ID排序。\n\ncallable接口的返回值用什么接收\n\nCallable相比Runnable接口的好处\nCallable接口 有返回值,返回值用FutureTask的get方法接收Callable接口可以抛出异常\nclass CallTest implements Callable&#123;\t@Override\tpublic Integer call()&#123;\t\treturn 123;\t&#125;&#125;public static void main(String[] args) throws Exception &#123;//\t\tnew Thread(new Runable1(), &quot;RunnableName&quot;).start();\t\tFutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new CallTest());\t\t//lambda表达式优化\t\tFutureTask&lt;String&gt; futureTask1=new FutureTask&lt;&gt;(()-&gt; &quot;lambda表达式优化&quot;);\t\t\t\tnew Thread(futureTask1).start();\t\tSystem.out.println(&quot;Callable接口(lambda表达式)返回数据&quot;+futureTask1.get());\t\tnew Thread(futureTask).start();\t\tSystem.out.println(&quot;Callable接口返回数据&quot;+futureTask.get());\t&#125;&#125;\n\n\n\n\nsleep() 方法 和wait() 方法\n\nsleep方法是Thread类下的\n线程调用sleep方法虽然休眠了 但是不会释放锁对象\nwait() 方法是Object类下的\nwait方法会让出CPU的执行权, 调用wait方法后 需要用notify&#x2F;notifyall 来唤醒线程\n/** * @ Author     ：赵棱泉. * @ Date       ：Created in 23:21 2022/2/1 * @ Description： */public class Task implements Runnable &#123;\tprivate static synchronized void threadtest() &#123;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;获取到了锁&quot;);\t\ttry &#123;\t\t\tThread.sleep(2000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;释放锁&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\tnew Thread(new Task()).start();\t\tnew Thread(new Task()).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tthreadtest();\t&#125;&#125;\n\n\n\n子类可以重写父类的构造方法吗\n\n不能!!\n每个类的构造方法和类名都是相同的,\n如果重写了构造方法 相当于子类和父类名是相同的, 不可实现\n\nMySQL排序关键字 和分组关键字\n\n排序关键字order by\n分组关键字group by\n\nRedis 缓存雪崩讲一下\n\n缓存雪崩指的是大面积key值在同一时间段失效,大量的请求落到数据库上,导致数据库宕机\n","categories":["面试总结"],"tags":["interview"]},{"title":"线程池参数","url":"/2022/04/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/","content":"合理利用线程池能够带来三个好处。\n\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n第三：提高线程的可管理性。\n\ncorePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n线程池基本工作流程\n\n首先用ThreadpoolExecutor创建一个新的线程池\n\n首先,当任务到达时,运行的线程数&lt;corepoolsize,会新建线程,\n如果运行的线程数&gt;&#x3D;corepoolsize,线程会进入队列,而不添加新的线程\n若队列是new ArrayBlockingQueue&lt;&gt;()有界队列,当队列满了之后,再有新的任务到达,此时还没到达maximumpoolsize,就会新建线程,运行任务\n有界队列ArrayBlockingQueue&lt;Integer&gt; queue = new ArrayBlockingQueue&lt;Integer&gt;(1);\n\n\n无界队列LinkedBlockingQueue&lt;Integer&gt; queue = new LinkedBlockingQueue&lt;&gt;();  \n\n对于无届队列来说,\nnewFixedThreadPool和newSingleThreadExecutor底层用的是无届队列\n\n\n特殊的队列package cn.zlq.SynchronousQueue;import java.util.concurrent.SynchronousQueue;/** * @ Author     ：zhaolengquan. * @ Date       ：Created in 14:34 2022/4/15 * @ Description： */public class Test &#123;\tpublic static void main(String[] args) throws InterruptedException &#123;\t\tSynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;();\t\tThread thread1 = new Thread(() -&gt; &#123;\t\t\tSystem.out.println(&quot;put thread start&quot;);\t\t\ttry &#123;\t\t\t\tqueue.put(1);\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(&quot;put thread end&quot;);\t\t&#125;);\t\tThread thread2 = new Thread(() -&gt; &#123;\t\t\tSystem.out.println(&quot;take thread start&quot;);\t\t\ttry &#123;\t\t\t\tSystem.out.println(&quot;take from putThread: &quot; + queue.take());\t\t\t&#125; catch (InterruptedException e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t\tSystem.out.println(&quot;take thread end&quot;);\t\t&#125;);\t\tthread1.start();\t\tThread.sleep(1000);\t\tthread2.start();\t&#125;&#125;\n\n先看结果\nput线程执行后就被阻塞了,只有消息被消费后,put线程才可以返回.\n\n默认是非公平 也即是栈结构,公平模式下用的是队列结构\n底层实现请前往博客\nhttps://blog.csdn.net/yanyan19880509/article/details/52562039\n\nnewCachedThreadPool底层用的就是这个队列\n\n","categories":["JUC"],"tags":["线程池"]}]