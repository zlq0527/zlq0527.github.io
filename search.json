[{"title":"MySQL实战45讲总结","url":"/2022/03/12/Mysql/","content":"MySQL自增主键\n页分裂 页合并\n回表操作\n二级索引放的数据是主键ID\n\n\n2022-03-10 10:27:44\nMySQL缓存 (8.0以后已经弃用), 对基础表的任何修改 都会使所有的缓存失效,\n如果想要一条SQL命中缓存,需要和之前存入缓存的SQL完全一致,参数顺序不同或 多了空格 都会导致不会命中缓存.\n除非表是一张静态表 没有更新只有查询的需求 可以使用缓存提高效率\n如果没有命中缓存 SQL就来到了解析器 首先进入分析器  进行  词法分析 然后语法分析(看语句是否合法)\n分析器任务完成后, 来到优化器\n优化器的作用是 索引选择 和表连接顺序(join)\n一条查询语句的执行需要经过\n连接器-分析器-优化器-执行器\n连接器(建立连接,权限认证)\n分析器(分析词法,语法是否正确)\n优化器(选择索引和连接方式)\n执行器(执行之前需要看用户有没有对表的查询权限)\n","categories":["MySQL"],"tags":["MySQL","索引"]},{"title":"面试总结","url":"/2022/03/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"\n重写和重载\n\n重写是 子类继承父类, 然后子类可以重写父类的方法\n重写时,参数类型,参数个数,方法名都要和被重写的方法完全一致!\n重写时,父类private方法不能被重写(爸爸的隐私,孩子不能看):sunglasses::scream:\n子类重写的方法不能比父类的修饰符更严格\n重载发生在一个类中,方法名相同,参数个数,参数类型,参数顺序 不相同 \n\nMySQL连接查询和联合查询哪个性能更好\n\n\nRedis持久化方式 -RDB和AOF的优缺点\n\nRDB是快照方式需要恢复数据的时候直接把RDB快照加载就行\n如果数据较多, 保存快照的时间比较久\nAOF是写命令追加到日志, 日志文件会越来越大\n\nRDB的缺点\n\nRDB快照一般都是每五分钟或者更长时间更新一次,如果Redis宕机 可能会丢失近几分钟的数据. 这个问题就是RDB最大的缺点, 不适合做第一恢复方案\nRDB fork子进程进行数据备份,如果数据量特别大,等待时间变久,.\n所以 一般不要让RDB备份时间间隔太久, 否则每次生成的RDB文件太大了，对Redis本身的性能可能会有影响的；\n\nAOF优缺点\n\n一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据，Redis进程挂了，最多丢掉1秒钟的数据；\nAOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修；\n\nMySQL主键索引有什么用\n\n主键保证唯一性 &amp;&amp; 主键列不为NULL\n\nMySQL表主键是必须的吗\n\n主键不是必须的,简单的表可以不设置主键, 设置主键能提高表的查询效率\n\ncallable接口的返回值用什么接收\n\nCallable相比Runnable接口的好处\nCallable接口 有返回值,返回值用FutureTask的get方法接收Callable接口可以抛出异常\nclass CallTest implements Callable&#123;\t@Override\tpublic Integer call()&#123;\t\treturn 123;\t&#125;&#125;public static void main(String[] args) throws Exception &#123;//\t\tnew Thread(new Runable1(), &quot;RunnableName&quot;).start();\t\tFutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new CallTest());\t\t//lambda表达式优化\t\tFutureTask&lt;String&gt; futureTask1=new FutureTask&lt;&gt;(()-&gt; &quot;lambda表达式优化&quot;);\t\t\t\tnew Thread(futureTask1).start();\t\tSystem.out.println(&quot;Callable接口(lambda表达式)返回数据&quot;+futureTask1.get());\t\tnew Thread(futureTask).start();\t\tSystem.out.println(&quot;Callable接口返回数据&quot;+futureTask.get());\t&#125;&#125;\n\n\n\n\n\n\n左连接和右连接有什么区别\n\n\nsleep() 方法 和wait() 方法\n\nsleep方法是Thread类下的\n线程调用sleep方法虽然休眠了 但是不会释放锁对象\nwait() 方法是Object类下的\nwait方法会让出CPU的执行权, 调用wait方法后 需要用notify&#x2F;notifyall 来唤醒线程\n/** * @ Author     ：赵棱泉. * @ Date       ：Created in 23:21 2022/2/1 * @ Description： */public class Task implements Runnable &#123;\tprivate static synchronized void threadtest() &#123;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;获取到了锁&quot;);\t\ttry &#123;\t\t\tThread.sleep(2000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;释放锁&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\tnew Thread(new Task()).start();\t\tnew Thread(new Task()).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tthreadtest();\t&#125;&#125;\n\n\n\n\n\n\n子类可以重写父类的构造方法吗\n\n不能!!\n每个类的构造方法和类名都是相同的,\n如果重写了构造方法 相当于子类和父类名是相同的, 不可实现\n\nMySQL排序关键字 和分组关键字\n\n排序关键字order by\n分组关键字group by\n\nRedis 缓存雪崩讲一下\n\n缓存雪崩指的是大面积key值在同一时间段失效,大量的请求落到数据库上,导致数据库宕机\n","categories":["面试总结"],"tags":["/interview"]}]