[{"title":"Bean作用域","url":"/2022/03/17/Bean%E4%BD%9C%E7%94%A8%E5%9F%9F/","content":"Bean的作用域\nSingleton\n\nBean的作用域默认是单例的\n\nPrototype\n\n每次创建都会返回一个新的Bean实例\n\nrequest 和Session 在web中有效\n\nrequest 每次的HTTP请求都会产生一个新的Bean  仅在当前http请求中有效\nSession 每一次来自新 session的HTTP请求都会产生一个新的 bean该bean仅在当前HTTPsession 内有效。\n怎么配置Spring bean 的作用域\n\n在XML中配置\n\n&lt;bean id=&quot;......&quot;  class=&quot;......&quot;   scope=&quot;Singleton&quot;&gt;&lt;/bean&gt;\n\n\n使用注解@Scope 配置\n\n@Repository@Scope(&quot;prototype&quot;)public class UserDao &#123;    public String hello() &#123;        return &quot;userdao&quot;;    &#125;&#125;\n\n\n\n","categories":["框架"],"tags":["Spring"]},{"title":"MySQL实战45讲总结","url":"/2022/03/12/Mysql/","content":"MySQL自增主键\n页分裂 页合并\n回表操作\n二级索引放的数据是主键ID\n\n\n2022-03-10 10:27:44\nMySQL缓存 (8.0以后已经弃用), 对基础表的任何修改 都会使所有的缓存失效,\n如果想要一条SQL命中缓存,需要和之前存入缓存的SQL完全一致,参数顺序不同或 多了空格 都会导致不会命中缓存.\n除非表是一张静态表 没有更新只有查询的需求 可以使用缓存提高效率\n如果没有命中缓存 SQL就来到了解析器 首先进入分析器  进行  词法分析 然后语法分析(看语句是否合法)\n分析器任务完成后, 来到优化器\n优化器的作用是 索引选择 和表连接顺序(join)\n一条查询语句的执行需要经过\n连接器-分析器-优化器-执行器\n连接器(建立连接,权限认证)\n分析器(分析词法,语法是否正确)\n优化器(选择索引和连接方式)\n执行器(执行之前需要看用户有没有对表的查询权限)\n","categories":["MySQL"],"tags":["MySQL"]},{"title":"Nginx负载均衡","url":"/2022/03/16/Nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/","content":"什么是反向代理服务器反向代理应该是Nginx使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。反向代理通过proxy_pass指令来实现。\nNginx配置#HTTP里的配置        upstream mydata &#123;        #mydata是自己起的名字,可以随便起,下面 location的proxy_pass 有用到        \t\t\t\t# weight是权重          \t\t\t\t# 权重的数值越大，被分配到的几率也更大                server localhost:8181 weight=2;                server localhost:8182 weight=1;        &#125;    server &#123;        listen       80; #服务器监听80端口        server_name  localhost;        location / &#123;            root   html;            index  index.html index.htm;                       # 监听地址, mydata 即用户访问的地址            proxy_pass http://mydata  ;        &#125;\n\n\n\n引入Thymeleaf视图解析器必要的start依赖\n    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;    &lt;/dependency&gt;\n\n\n\nJava代码配置localhost:8181package com.example.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class NginxController &#123;\t@RequestMapping(&quot;/&quot;)\tpublic String test() &#123;\t\treturn &quot;Nginx&quot;;\t&#125;&#125;\n\nNginx.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    localhost8181: hello Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\napplication.ymlserver:  port: 8181    mvc:    static-path-pattern: /**  web:    resources:      static-locations: classpath:/templates/,classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/\n\nlocalhost:8182controller不需要改变,application.yml里port改成8182\nhtml稍做变化\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;    localhost8182: hello Nginx&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n用Maven把项目打成Jar包后 修改html和端口再次打包\n\njava -jar SpringBoottest-0.0.1-SNAPSHOT.jar \njava -jar SpringBoottest-0.0.1-SNAPSHOT2.jar \n访问Nginx  localhost:80\n刷新能得到不同的效果\n\n\n\n\nNginx负载均衡的几种方式普通轮询算法    upstream mydata &#123;            server localhost:8181             server localhost:8182     &#125;server &#123;    listen       80; #服务器监听80端口    server_name  localhost;    location / &#123;        root   html;        index  index.html index.htm;               # 监听地址, mydata 即用户访问的地址        proxy_pass http://mydata  ;    &#125;\n\n基于比例加权平均upstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;&#125;\n\n基于IP路由负载上面两种方式都有一个问题 如果我们的请求不是无状态的时候(采用Session保存数据),比如我们把登录信息保存到了Session中,那么跳转到另外一台服务器的时候,就需要重新登陆了,此时可以在upstream 配置中加一行 ip_hash, ip_hash首先把每一个请求 先获得请求的ip地址映射成一个hash值,这样的话每个ip都可以固定访问一台后端服务器,解决了Session跨域的问题\nupstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;        ip_hash;&#125;\n\n\n\n基于服务器响应时间负载分配根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配。\nupstream mydata &#123;        server localhost:8181 weight=5;        server localhost:8182 weight=2;       \tfair;&#125;\n\n\n\n对不同域名实现负载均衡    upstream AdminConfig &#123;            server localhost:8181             server localhost:8182     &#125;        upstream StudentConfig &#123;            server localhost:8181             server localhost:8182     &#125;server &#123;    listen       80; #服务器监听80端口    server_name  localhost;    location /Admin/ &#123;        root   html;        index  index.html index.htm;       # 监听地址, mydata 即用户访问的地址        proxy_pass http://AdminConfig  ;    &#125;        location /Student/ &#123;        root   html;        index  index.html index.htm;       # 监听地址, mydata 即用户访问的地址        proxy_pass http://StudentConfig  ;    &#125;\n\n\n\n","categories":["Nginx"],"tags":["Nginx","负载均衡"]},{"title":"Volatile关键字","url":"/2022/03/14/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/","content":"为什么会出现线程不安全的问题volatile既然是与线程安全有关的问题，那我们先来了解一下计算机在处理数据的过程中为什么会出现线程不安全的问题。\n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中会涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。\n为了处理这个问题，在CPU里面就有了高速缓存(Cache)的概念。当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n我举个简单的例子，比如cpu在执行下面这段代码的时候,\nt=t+1;\n\n\n\n会先从高速缓存中查看是否有t的值，如果有，则直接拿来使用，如果没有，则会从主存中读取，读取之后会复制一份存放在高速缓存中方便下次使用。之后cpu进行对t加1操作，然后把数据写入高速缓存，最后会把高速缓存中的数据刷新到主存中。\n这一过程在单线程中运行是没问题的, 在多线程中运行就会出现问题,在多核CPU中,每个线程可能运行在不同的CPU中,每个CPU都有自己的高速缓存,这时就会出现同一个变量在两个高速缓存中的值不一致的问题了.\n假设此时t的值为0,两个线程同时读取了t的值,并存到了各自的高速缓存中,线程1对t进行了加1的操作,此时t的值为1,并且把t的值写回主内存,,但是线程2中高速缓存的值还是0,进行加1操作后,t的值还是1 然后把t写回主内存.此时两个线程都对t的值进行了+1操作,但是主内存中的值不是2 这就出现了数据丢失的问题,线程不安全.\njava中线程安全问题java语言在处理线程安全问题的时候,会有自己的处理机制,比如synchronized关键字, volatile关键字\njava内存模型规定所有的变量都是存在主内存中,每个线程又都有自己的工作内存(高速缓存),线程对数据的所有操作必须在自己的工作内存中进行,而不是直接在主存中操作.并且每个线程不能访问其他线程的工作内存.java中的每个线程都有自己的工作空间,因此多个线程在处理一个共享变量的时候,就会出现安全问题.\n\n共享变量\n\n上面举例的t就是一个共享变量,共享变量就是能够被多个线程访问到的变量.在java中共享变量包括实例变量,静态变量,数组元素, 他们都被存放在堆内存中\nvolatile关键字可见性可见性的意思就是在多线程环境下,一个变量如果被一个 线程修改,其他线程能够立即知道这个线程被修改了,当线程读取这个变量的时候,去主内存中读取而不是自己的工作内存.\n上面的例子中线程2读取变量时从主内存中读取,就能读到最新的线程1修改后的值,然后再进行+1操作,这样两边的数据就一致了.\n如果一个变量被声明为volatile,那么这个变量就具有了可见性的特征,这就是volatile的作用之一\n缓存一致性协议线程中的处理器会一直在总线上嗅探其内部缓存中的内存地址在\n其他处理器的操作情况，一旦嗅探到某处处理器打算修改其内存地址中的值，而该内存地址刚好也在自己的内部缓存中，那么处理器就会强制让自己对该缓存地址的无效。所以当该处理器要访问该数据的时候，由于发现自己缓存的数据无效了，就会去主存中访问。\n有序性实际上,当我们把代码写好之后,虚拟机不一定会按照我们写的代码的顺序来执行,例如下面两行代码\nint a = 1;int b = 2;\n\n对于这两句代码，你会发现无论是先执行a &#x3D; 1还是执行b &#x3D; 2，都不会对a,b最终的值造成影响。所以虚拟机在编译的时候，是有可能把他们进行重排序的。\n为什么要重排序呢,\n假如执行int a&#x3D;1 需要100ms的时间,执行int b&#x3D;2需要1ms的时间,并且这两行代码并没有依赖关系,最终不会对ab的值造成影响,那肯定先执行b&#x3D;2这行代码了.\nvolatile真的能保证一个变量的线程安全吗我们通过上面的讲解，发现volatile关键字还是挺有用的，不但能够保证变量的可见性，还能保证代码的有序性。那么，它真的能够保证一个变量在多线程环境下都能被正确的使用吗？答案是否定的。原因是因为Java里面的运算并非是原子操作。\n原子操作原子操作：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。也就是说，处理器要嘛把这组操作全部执行完，中间不允许被其他操作所打断，要嘛这组操作不要执行。刚才说Java里面的运行并非是原子操作。我举个例子，例如这句代码\nint a=b+1;\n\n处理器在处理代码的时候，需要处理以下三个操作：\n\n从内存中读取b的值。\n进行a &#x3D; b + 1这个运算\n把a的值写回到内存中\n\n而这三个操作处理器是不一定就会连续执行的，有可能执行了第一个操作之后，处理器就跑去执行别的操作的。\nvolatile无法保证原子性的例子public class test4 &#123;\tprivate static volatile int i = 0;\tpublic static void main(String[] args) &#123;\t\tfor (int j = 0; j &lt; 10; j++) &#123;\t\t\tnew Thread(() -&gt; &#123;\t\t\t\tfor (int k = 0; k &lt; 1000; k++) &#123;\t\t\t\t\ti = i + 1;\t\t\t\t&#125;\t\t\t&#125;).start();\t\t&#125;\t\tSystem.out.println(i);\t&#125;&#125;\n\n\n例如：线程1读取了t的值，假如t &#x3D; 0。之后线程2读取了t的值，此时t &#x3D; 0。然后线程1执行了加1的操作，此时t &#x3D; 1。但是这个时候，处理器还没有把t &#x3D; 1的值写回主存中。这个时候处理器跑去执行线程2，注意，刚才线程2已经读取了t的值，所以这个时候并不会再去读取t的值了，所以此时t的值还是0，然后线程2执行了对t的加1操作，此时t &#x3D;1 。这个时候，就出现了线程安全问题了，两个线程都对t执行了加1操作，但t的值却是1。所以说，volatile关键字并不一定能够保证变量的安全性。\n什么情况下volatile能够保证线程安全刚才虽然说，volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：\n\n运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。\n变量不需要与其他状态变量共同参与不变约束。\n\n","categories":["JUC"],"tags":["volatile"]},{"title":"MySQL索引分析_01","url":"/2022/03/13/index/","content":"\n表结构如下\n\n表名为T,主键是id 自增, 新建索引name.\nCREATE TABLE `T` (  `id` int NOT NULL AUTO_INCREMENT,  `name` varchar(255) DEFAULT NULL,  `age` int DEFAULT NULL,  `adress` varchar(255) DEFAULT NULL,  PRIMARY KEY (`id`),  KEY `test` (`name`)) ENGINE=InnoDB AUTO_INCREMENT=18 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n\n\nusing IndexEXPLAIN SELECT id from t where name =&#x27;lisi&#x27;;\n\n使用了覆盖索引 要查的id 就在name索引的叶子结点上\nusing where在使用索引的情况下,需要回表查询数据\nusing where &amp; using IndexEXPLAIN SELECT id from t where name LIKE &#x27;li%&#x27;;\n\n使用了索引,所需要的数据在索引列上都能找到, 不需要回表操作\nusing Index conditionEXPLAIN SELECT * from t where name LIKE &#x27;li%&#x27;;\n\n虽然使用了索引,但是还需要回表查询数据\n索引下推在MySQL5.6以后引入新特性 索引下推\nCREATE INDEX test2 ON T (name,age)EXPLAIN SELECT * from t WHERE name like &#x27;li%&#x27; AND age =10 \n\n在MySQL5.6版本以前 上述SQL执行流程:\n因为name和age是联合索引,但是因为name是范围查询(&gt; &lt; between like) 根据name排序之后age索引就失效了 所以就带着id去回表查询age是否复合条件\n和下图(列名不同)但原理相同\n\nMySQL5.6以后引入索引下推SQL执行流程是\n在根据name查询以后,InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。\n","categories":["MySQL"],"tags":["索引"]},{"title":"面试总结","url":"/2022/03/12/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/","content":"\n重写和重载\n\n重写是 子类继承父类, 然后子类可以重写父类的方法\n重写时,参数类型,参数个数,方法名都要和被重写的方法完全一致!\n重写时,父类private方法不能被重写(爸爸的隐私,孩子不能看)\n子类重写的方法不能比父类的修饰符更严格\n重载发生在一个类中,方法名相同,参数个数,参数类型,参数顺序 不相同 \n\nRedis持久化方式 -RDB和AOF的优缺点\n\nRDB是快照方式需要恢复数据的时候直接把RDB快照加载就行\n如果数据较多, 保存快照的时间比较久\nAOF是写命令追加到日志, 日志文件会越来越大\n\nRDB的缺点\n\nRDB快照一般都是每五分钟或者更长时间更新一次,如果Redis宕机 可能会丢失近几分钟的数据. 这个问题就是RDB最大的缺点, 不适合做第一恢复方案\nRDB fork子进程进行数据备份,如果数据量特别大,等待时间变久,.\n所以 一般不要让RDB备份时间间隔太久, 否则每次生成的RDB文件太大了，对Redis本身的性能可能会有影响的；\n\nAOF优缺点\n\n一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据，Redis进程挂了，最多丢掉1秒钟的数据；\nAOF日志文件以append-only模式写入，所以没有任何磁盘寻址的开销，写入性能非常高，而且文件不容易破损，即使文件尾部破损，也很容易修；\n\nMySQL主键索引有什么用\n\n主键保证唯一性 &amp;&amp; 主键列不为NULL\n\nMySQL表主键是必须的吗\n\n主键不是必须的,简单的表可以不设置主键, 设置主键能提高表的查询效率\n如果没有定义主键,innoDB会选择唯一非空索引作为主键,如果没有的话 innoDB会自动生成一个包含了ROW_ID值的列作为聚簇索引,行都会根据这个ROW_ID排序。\n\ncallable接口的返回值用什么接收\n\nCallable相比Runnable接口的好处\nCallable接口 有返回值,返回值用FutureTask的get方法接收Callable接口可以抛出异常\nclass CallTest implements Callable&#123;\t@Override\tpublic Integer call()&#123;\t\treturn 123;\t&#125;&#125;public static void main(String[] args) throws Exception &#123;//\t\tnew Thread(new Runable1(), &quot;RunnableName&quot;).start();\t\tFutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(new CallTest());\t\t//lambda表达式优化\t\tFutureTask&lt;String&gt; futureTask1=new FutureTask&lt;&gt;(()-&gt; &quot;lambda表达式优化&quot;);\t\t\t\tnew Thread(futureTask1).start();\t\tSystem.out.println(&quot;Callable接口(lambda表达式)返回数据&quot;+futureTask1.get());\t\tnew Thread(futureTask).start();\t\tSystem.out.println(&quot;Callable接口返回数据&quot;+futureTask.get());\t&#125;&#125;\n\n\n\n\nsleep() 方法 和wait() 方法\n\nsleep方法是Thread类下的\n线程调用sleep方法虽然休眠了 但是不会释放锁对象\nwait() 方法是Object类下的\nwait方法会让出CPU的执行权, 调用wait方法后 需要用notify&#x2F;notifyall 来唤醒线程\n/** * @ Author     ：赵棱泉. * @ Date       ：Created in 23:21 2022/2/1 * @ Description： */public class Task implements Runnable &#123;\tprivate static synchronized void threadtest() &#123;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;获取到了锁&quot;);\t\ttry &#123;\t\t\tThread.sleep(2000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\tSystem.out.println(Thread.currentThread().getName() + &quot;释放锁&quot;);\t&#125;\tpublic static void main(String[] args) &#123;\t\tnew Thread(new Task()).start();\t\tnew Thread(new Task()).start();\t&#125;\t@Override\tpublic void run() &#123;\t\tthreadtest();\t&#125;&#125;\n\n\n\n子类可以重写父类的构造方法吗\n\n不能!!\n每个类的构造方法和类名都是相同的,\n如果重写了构造方法 相当于子类和父类名是相同的, 不可实现\n\nMySQL排序关键字 和分组关键字\n\n排序关键字order by\n分组关键字group by\n\nRedis 缓存雪崩讲一下\n\n缓存雪崩指的是大面积key值在同一时间段失效,大量的请求落到数据库上,导致数据库宕机\n","categories":["面试总结"],"tags":["interview"]}]